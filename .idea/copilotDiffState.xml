<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bot/handlers/admin.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bot/handlers/admin.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;&#10;from aiogram import Router&#10;from aiogram.filters import Command&#10;from aiogram.types import Message&#10;from aiogram.enums import ParseMode&#10;&#10;from sqlalchemy import select, func, text&#10;&#10;from bot.config import settings&#10;from bot.database.session import get_session&#10;from bot.database.models import User, Homework&#10;&#10;&#10;router = Router(name=&quot;admin&quot;)&#10;&#10;&#10;def _is_admin(message: Message) -&gt; bool:&#10;    &quot;&quot;&quot;Проверяет, является ли пользователь администратором&quot;&quot;&quot;&#10;    return bool(message.from_user and message.from_user.id in settings.ADMIN_IDS)&#10;&#10;&#10;def admin_required(func):&#10;    &quot;&quot;&quot;Декоратор для проверки прав администратора&quot;&quot;&quot;&#10;    @wraps(func)&#10;    async def wrapper(message: Message, *args, **kwargs):&#10;        if not _is_admin(message):&#10;            await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;            return&#10;        return await func(message, *args, **kwargs)&#10;    return wrapper&#10;&#10;&#10;@router.message(Command(&quot;broadcast&quot;))&#10;async def cmd_broadcast(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Отправка сообщения всем пользователям бота&#10;    Использование: /broadcast &lt;текст сообщения&gt;&#10;    &quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;        return&#10;&#10;    text_parts = message.text.split(maxsplit=1)&#10;    if len(text_parts) &lt; 2:&#10;        await message.answer(&#10;            &quot; &lt;b&gt;Массовая рассылка&lt;/b&gt;\n\n&quot;&#10;            &quot;Использование: &lt;code&gt;/broadcast &amp;lt;текст сообщения&amp;gt;&lt;/code&gt;\n\n&quot;&#10;            &quot;Пример: &lt;code&gt;/broadcast Важное объявление для всех студентов!&lt;/code&gt;&quot;,&#10;            parse_mode=&quot;HTML&quot;&#10;        )&#10;        return&#10;&#10;    broadcast_text = text_parts[1]&#10;&#10;    async for db in get_session():&#10;        users = (await db.execute(select(User).where(User.telegram_id.is_not(None)))).scalars().all()&#10;&#10;        success_count = 0&#10;        error_count = 0&#10;&#10;        status_message = await message.answer(&quot; Начинаю рассылку...&quot;)&#10;&#10;        for user in users:&#10;            try:&#10;                await message.bot.send_message(user.telegram_id, broadcast_text)&#10;                success_count += 1&#10;            except Exception:&#10;                error_count += 1&#10;&#10;        result_text = (&#10;            f&quot; &lt;b&gt;Результаты рассылки:&lt;/b&gt;\n\n&quot;&#10;            f&quot;✅ Успешно отправлено: {success_count}\n&quot;&#10;            f&quot;❌ Ошибок: {error_count}\n&quot;&#10;            f&quot; Всего пользователей: {len(users)}&quot;&#10;        )&#10;&#10;        await status_message.edit_text(result_text, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;stats&quot;))&#10;async def cmd_stats(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;Показывает подробную статистику использования бота&quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;        return&#10;&#10;    async for db in get_session():&#10;        # Основные счетчики&#10;        users_count = (await db.execute(select(func.count()).select_from(User))).scalar_one()&#10;        active_users = (await db.execute(&#10;            select(func.count()).select_from(User).where(User.telegram_id.is_not(None))&#10;        )).scalar_one()&#10;&#10;        # Статистика домашних заданий&#10;        total_homeworks = (await db.execute(select(func.count()).select_from(Homework))).scalar_one()&#10;        active_homeworks = (await db.execute(&#10;            select(func.count()).select_from(Homework).where(&#10;                Homework.is_done.is_(False),&#10;                Homework.is_archived.is_(False)&#10;            )&#10;        )).scalar_one()&#10;        completed_homeworks = (await db.execute(&#10;            select(func.count()).select_from(Homework).where(Homework.is_done.is_(True))&#10;        )).scalar_one()&#10;        archived_homeworks = (await db.execute(&#10;            select(func.count()).select_from(Homework).where(Homework.is_archived.is_(True))&#10;        )).scalar_one()&#10;&#10;        # Статистика расписания&#10;        from bot.database.models import ScheduleLesson&#10;        schedule_lessons = (await db.execute(select(func.count()).select_from(ScheduleLesson))).scalar_one()&#10;&#10;        stats_text = f&quot;&quot;&quot;&#10; &lt;b&gt;Статистика SDU Homework Bot&lt;/b&gt;&#10;&#10; &lt;b&gt;Пользователи:&lt;/b&gt;&#10;• Всего зарегистрировано: {users_count}&#10;• Активных (с Telegram ID): {active_users}&#10;&#10; &lt;b&gt;Домашние задания:&lt;/b&gt;&#10;• Всего создано: {total_homeworks}&#10;• Активных: {active_homeworks}&#10;• Выполнено: {completed_homeworks}&#10;• В архиве: {archived_homeworks}&#10;&#10; &lt;b&gt;Расписание:&lt;/b&gt;&#10;• Всего занятий в базе: {schedule_lessons}&#10;&#10; &lt;b&gt;Система:&lt;/b&gt;&#10;• Планировщик: Активен (проверки каждый час в XX:15)&#10;• Архивация: Еженедельно по понедельникам в 02:00&#10;• Напоминания: 20:00 ежедневно&#10;&quot;&quot;&quot;&#10;&#10;        await message.answer(stats_text, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;thn&quot;))&#10;async def cmd_test_homework_now(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test Homework Now - тестовая команда для проверки системы напоминаний&#10;    Симулирует окончание урока и проверяет работу уведомлений&#10;    &quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения это�� команды&quot;)&#10;        return&#10;&#10;    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton&#10;    from bot.services.reminder_after_lesson import unified_lesson_check&#10;&#10;    await message.answer(&quot; &lt;b&gt;Тестирование системы напоминаний&lt;/b&gt;\n\nЗапускаю проверки...&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;    # 1. Тестовое сообщение с кнопками&#10;    kb = InlineKeyboardMarkup(&#10;        inline_keyboard=[&#10;            [&#10;                InlineKeyboardButton(text=&quot;✅ Да&quot;, callback_data=f&quot;dz:test:yes&quot;),&#10;                InlineKeyboardButton(text=&quot;❌ Нет&quot;, callback_data=f&quot;dz:test:no&quot;),&#10;            ]&#10;        ]&#10;    )&#10;&#10;    await message.answer(&#10;        &quot; &lt;b&gt;ТЕСТ:&lt;/b&gt; Занятие 'TEST101 (Тестовая проверка) - T123' скоро закончится (через 5 минут).\n\n&quot;&#10;        &quot; Было ли домашнее задание?&quot;,&#10;        reply_markup=kb,&#10;        parse_mode=&quot;HTML&quot;&#10;    )&#10;&#10;    # 2. Запуск функции проверки напоминаний&#10;    try:&#10;        await unified_lesson_check(message.bot)&#10;        await message.answer(&quot;✅ &lt;b&gt;Тест завершен:&lt;/b&gt; Функция unified_lesson_check выполнена успе��но&quot;, parse_mode=&quot;HTML&quot;)&#10;    except Exception as e:&#10;        await message.answer(f&quot;❌ &lt;b&gt;Ошибка при тестировании:&lt;/b&gt; {str(e)}&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;sql&quot;))&#10;async def sql_for_admins(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;Выполнение SQL-запросов для администраторов&quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;        return&#10;&#10;    # Извлекаем SQL-запрос из команды&#10;    text_parts = message.text.split(maxsplit=1)&#10;    if len(text_parts) &lt; 2:&#10;        await message.answer(&#10;            &quot; &lt;b&gt;Выполнение SQL-запросов&lt;/b&gt;\n\n&quot;&#10;            &quot;Использование: &lt;code&gt;/sql &amp;lt;SQL-запрос&amp;gt;&lt;/code&gt;\n\n&quot;&#10;            &quot;Примеры:\n&quot;&#10;            &quot;&lt;code&gt;/sql SELECT * FROM users LIMIT 5&lt;/code&gt;\n&quot;&#10;            &quot;&lt;code&gt;/sql SELECT COUNT(*) FROM homeworks&lt;/code&gt;&quot;,&#10;            parse_mode=&quot;HTML&quot;&#10;        )&#10;        return&#10;&#10;    query = text_parts[1].strip()&#10;&#10;    async for db in get_session():&#10;        try:&#10;            # Выполняем SQL-запрос&#10;            result = await db.execute(text(query))&#10;&#10;            # Проверяем тип результата&#10;            if query.upper().strip().startswith('SELECT'):&#10;                # Для SELECT-запросов&#10;                rows = result.fetchall()&#10;&#10;                if not rows:&#10;                    await message.answer(&quot; Результатов н�� найдено.&quot;)&#10;                    return&#10;&#10;                # Получаем заголовки столбцов&#10;                headers = list(result.keys())&#10;&#10;                # Формируем таблицу в формате Markdown&#10;                table = &quot;| &quot; + &quot; | &quot;.join(headers) + &quot; |\n&quot;&#10;                table += &quot;|&quot; + &quot;|&quot;.join([&quot;---&quot; for _ in headers]) + &quot;|\n&quot;&#10;&#10;                for row in rows:&#10;                    row_data = [str(cell) if cell is not None else &quot;NULL&quot; for cell in row]&#10;                    table += &quot;| &quot; + &quot; | &quot;.join(row_data) + &quot; |\n&quot;&#10;&#10;                # Экранируем специальные символы Markdown&#10;                special_chars = [&#10;                    ('\\', '\\\\'),&#10;                    ('*', '\\*'),&#10;                    ('_', '\\_'),&#10;                    ('[', '\\['),&#10;                    (']', '\\]'),&#10;                    ('(', '\\('),&#10;                    (')', '\\)'),&#10;                    ('~', '\\~'),&#10;                    ('|', '\\|'),&#10;                    ('-', '\\-'),&#10;                    ('.', '\\.')&#10;                ]&#10;&#10;                for char, replacement in special_chars:&#10;                    table = table.replace(char, replacement)&#10;&#10;                # Разделяем на части, если слишком длинная&#10;                max_length = 4096&#10;                if len(table) &gt; max_length:&#10;                    parts = []&#10;                    while len(table) &gt; max_length:&#10;                        part = table[:max_length]&#10;                        parts.append(part)&#10;                        table = table[max_length:]&#10;&#10;                    if table:&#10;                        parts.append(table)&#10;&#10;                    for i, part in enumerate(parts):&#10;                        await message.answer(&#10;                            f&quot; &lt;b&gt;Результат SQL-запроса (часть {i+1}/{len(parts)}):&lt;/b&gt;\n\n&quot;&#10;                            f&quot;```\n{part}\n```&quot;,&#10;                            parse_mode=ParseMode.MARKDOWN_V2&#10;                        )&#10;                else:&#10;                    await message.answer(&#10;                        f&quot; &lt;b&gt;Результ��т SQL-запроса:&lt;/b&gt;\n\n&quot;&#10;                        f&quot;```\n{table}\n```&quot;,&#10;                        parse_mode=ParseMode.MARKDOWN_V2&#10;                    )&#10;            else:&#10;                # Для INSERT, UPDATE, DELETE запросов&#10;                await db.commit()  # Подтверждаем изменения&#10;                await message.answer(f&quot;✅ &lt;b&gt;SQL-запрос выполнен успешно&lt;/b&gt;\n\nЗатронуто строк: {result.rowcount}&quot;)&#10;&#10;        except Exception as e:&#10;            await message.answer(f&quot;❌ &lt;b&gt;Ошибка при выполнении запроса:&lt;/b&gt;\n\n&lt;code&gt;{str(e)}&lt;/code&gt;&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;help_admin&quot;))&#10;async def cmd_admin_help(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;Справка по админским командам&quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        return&#10;&#10;    admin_help = &quot;&quot;&quot;&#10; &lt;b&gt;Справка для администраторов&lt;/b&gt;&#10;&#10; &lt;b&gt;/broadcast&lt;/b&gt; &amp;lt;текст&amp;gt; - Массовая рассылка&#10;   Отправляет сообщение всем пользователям бота&#10;   &#10; &lt;b&gt;/stats&lt;/b&gt; - Подробная статистика&#10;   Показывает количество пользователей, заданий, расписание&#10;   &#10; &lt;b&gt;/thn&lt;/b&gt; - Тест системы напоминаний&#10;   Проверяет работу уведомлений о домашних заданиях&#10;&#10; &lt;b&gt;/sql&lt;/b&gt; &amp;lt;запрос&amp;gt; - Выполнение SQL-запросов&#10;   Позволяет выполнять прямые запросы к базе данных&#10;   &#10; &lt;b&gt;Техническая информация:&lt;/b&gt;&#10;• Планировщики работают каждый час в XX:15&#10;• Архивация: понедельник 02:00&#10;• Вечерние напоминания: ежедневно 20:00&#10;• Автоматические проверки: unified_lesson_check&#10;&#10; &lt;b&gt;Мониторинг:&lt;/b&gt;&#10;Следите за логами для отслеживания работы планировщиков и ошибок в системе уведомлений.&#10;&#10;⚠️ &lt;b&gt;Осторожно с SQL:&lt;/b&gt;&#10;Команда /sql дает прямой доступ к базе данных. Используйте аккуратно!&#10;&quot;&quot;&quot;&#10;&#10;    await message.answer(admin_help, parse_mode=&quot;HTML&quot;)&#10;" />
              <option name="updatedContent" value="from __future__ import annotations&#10;from functools import wraps&#10;&#10;from aiogram import Router&#10;from aiogram.filters import Command&#10;from aiogram.types import Message&#10;from aiogram.enums import ParseMode&#10;&#10;from sqlalchemy import select, func, text&#10;&#10;from bot.config import settings&#10;from bot.database.session import get_session&#10;from bot.database.models import User, Homework&#10;&#10;&#10;router = Router(name=&quot;admin&quot;)&#10;&#10;&#10;def _is_admin(message: Message) -&gt; bool:&#10;    &quot;&quot;&quot;Проверяет, является ли пользователь администратором&quot;&quot;&quot;&#10;    return bool(message.from_user and message.from_user.id in settings.ADMIN_IDS)&#10;&#10;&#10;def admin_required(func):&#10;    &quot;&quot;&quot;Декоратор для проверки прав администратора&quot;&quot;&quot;&#10;    @wraps(func)&#10;    async def wrapper(message: Message, *args, **kwargs):&#10;        if not _is_admin(message):&#10;            await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;            return&#10;        return await func(message, *args, **kwargs)&#10;    return wrapper&#10;&#10;&#10;@router.message(Command(&quot;broadcast&quot;))&#10;async def cmd_broadcast(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Отправка сообщения всем пользователям бота&#10;    Использование: /broadcast &lt;текст сообщения&gt;&#10;    &quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;        return&#10;&#10;    text_parts = message.text.split(maxsplit=1)&#10;    if len(text_parts) &lt; 2:&#10;        await message.answer(&#10;            &quot; &lt;b&gt;Массовая рассылка&lt;/b&gt;\n\n&quot;&#10;            &quot;Использование: &lt;code&gt;/broadcast &amp;lt;текст сообщения&amp;gt;&lt;/code&gt;\n\n&quot;&#10;            &quot;Пример: &lt;code&gt;/broadcast Важное объявление для всех студентов!&lt;/code&gt;&quot;,&#10;            parse_mode=&quot;HTML&quot;&#10;        )&#10;        return&#10;&#10;    broadcast_text = text_parts[1]&#10;&#10;    async for db in get_session():&#10;        users = (await db.execute(select(User).where(User.telegram_id.is_not(None)))).scalars().all()&#10;&#10;        success_count = 0&#10;        error_count = 0&#10;&#10;        status_message = await message.answer(&quot; Начинаю рассылку...&quot;)&#10;&#10;        for user in users:&#10;            try:&#10;                await message.bot.send_message(user.telegram_id, broadcast_text)&#10;                success_count += 1&#10;            except Exception:&#10;                error_count += 1&#10;&#10;        result_text = (&#10;            f&quot; &lt;b&gt;Результаты рассылки:&lt;/b&gt;\n\n&quot;&#10;            f&quot;✅ Успешно отправлено: {success_count}\n&quot;&#10;            f&quot;❌ Ошибок: {error_count}\n&quot;&#10;            f&quot; Всего пользователей: {len(users)}&quot;&#10;        )&#10;&#10;        await status_message.edit_text(result_text, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;stats&quot;))&#10;async def cmd_stats(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;Показывает подробную статистику использования бота&quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;        return&#10;&#10;    async for db in get_session():&#10;        # Основные счетчики&#10;        users_count = (await db.execute(select(func.count()).select_from(User))).scalar_one()&#10;        active_users = (await db.execute(&#10;            select(func.count()).select_from(User).where(User.telegram_id.is_not(None))&#10;        )).scalar_one()&#10;&#10;        # Статистика домашних заданий&#10;        total_homeworks = (await db.execute(select(func.count()).select_from(Homework))).scalar_one()&#10;        active_homeworks = (await db.execute(&#10;            select(func.count()).select_from(Homework).where(&#10;                Homework.is_done.is_(False),&#10;                Homework.is_archived.is_(False)&#10;            )&#10;        )).scalar_one()&#10;        completed_homeworks = (await db.execute(&#10;            select(func.count()).select_from(Homework).where(Homework.is_done.is_(True))&#10;        )).scalar_one()&#10;        archived_homeworks = (await db.execute(&#10;            select(func.count()).select_from(Homework).where(Homework.is_archived.is_(True))&#10;        )).scalar_one()&#10;&#10;        # Статистика расписания&#10;        from bot.database.models import ScheduleLesson&#10;        schedule_lessons = (await db.execute(select(func.count()).select_from(ScheduleLesson))).scalar_one()&#10;&#10;        stats_text = f&quot;&quot;&quot;&#10; &lt;b&gt;Статистика SDU Homework Bot&lt;/b&gt;&#10;&#10; &lt;b&gt;Пользователи:&lt;/b&gt;&#10;• Всего зарегистрировано: {users_count}&#10;• Активных (с Telegram ID): {active_users}&#10;&#10; &lt;b&gt;Домашние задания:&lt;/b&gt;&#10;• Всего создано: {total_homeworks}&#10;• Активных: {active_homeworks}&#10;• Выполнено: {completed_homeworks}&#10;• В архиве: {archived_homeworks}&#10;&#10; &lt;b&gt;Расписание:&lt;/b&gt;&#10;• Всего занятий в базе: {schedule_lessons}&#10;&#10; &lt;b&gt;Система:&lt;/b&gt;&#10;• Планировщик: Активен (проверки каждый час в XX:15)&#10;• Архивация: Еженедельно по понедельникам в 02:00&#10;• Напоминания: 20:00 ежедневно&#10;&quot;&quot;&quot;&#10;&#10;        await message.answer(stats_text, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;thn&quot;))&#10;async def cmd_test_homework_now(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test Homework Now - тестовая команда для проверки системы напоминаний&#10;    Симулирует окончание урока и проверяет работу уведомлений&#10;    &quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения это�� команды&quot;)&#10;        return&#10;&#10;    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton&#10;    from bot.services.reminder_after_lesson import unified_lesson_check&#10;&#10;    await message.answer(&quot; &lt;b&gt;Тестирование системы напоминаний&lt;/b&gt;\n\nЗапускаю проверки...&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;    # 1. Тестовое сообщение с кнопками&#10;    kb = InlineKeyboardMarkup(&#10;        inline_keyboard=[&#10;            [&#10;                InlineKeyboardButton(text=&quot;✅ Да&quot;, callback_data=f&quot;dz:test:yes&quot;),&#10;                InlineKeyboardButton(text=&quot;❌ Нет&quot;, callback_data=f&quot;dz:test:no&quot;),&#10;            ]&#10;        ]&#10;    )&#10;&#10;    await message.answer(&#10;        &quot; &lt;b&gt;ТЕСТ:&lt;/b&gt; Занятие 'TEST101 (Тестовая проверка) - T123' скоро закончится (через 5 минут).\n\n&quot;&#10;        &quot; Было ли домашнее задание?&quot;,&#10;        reply_markup=kb,&#10;        parse_mode=&quot;HTML&quot;&#10;    )&#10;&#10;    # 2. Запуск функции проверки напоминаний&#10;    try:&#10;        await unified_lesson_check(message.bot)&#10;        await message.answer(&quot;✅ &lt;b&gt;Тест завершен:&lt;/b&gt; Функция unified_lesson_check выполнена успе��но&quot;, parse_mode=&quot;HTML&quot;)&#10;    except Exception as e:&#10;        await message.answer(f&quot;❌ &lt;b&gt;Ошибка при тестировании:&lt;/b&gt; {str(e)}&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;sql&quot;))&#10;async def sql_for_admins(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;Выполнение SQL-запросов для администраторов&quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        await message.answer(&quot;❌ Недостаточно прав для выполнения этой команды&quot;)&#10;        return&#10;&#10;    # Извлекаем SQL-запрос из команды&#10;    text_parts = message.text.split(maxsplit=1)&#10;    if len(text_parts) &lt; 2:&#10;        await message.answer(&#10;            &quot; &lt;b&gt;Выполнение SQL-запросов&lt;/b&gt;\n\n&quot;&#10;            &quot;Использование: &lt;code&gt;/sql &amp;lt;SQL-запрос&amp;gt;&lt;/code&gt;\n\n&quot;&#10;            &quot;Примеры:\n&quot;&#10;            &quot;&lt;code&gt;/sql SELECT * FROM users LIMIT 5&lt;/code&gt;\n&quot;&#10;            &quot;&lt;code&gt;/sql SELECT COUNT(*) FROM homeworks&lt;/code&gt;&quot;,&#10;            parse_mode=&quot;HTML&quot;&#10;        )&#10;        return&#10;&#10;    query = text_parts[1].strip()&#10;&#10;    async for db in get_session():&#10;        try:&#10;            # Выполняем SQL-запрос&#10;            result = await db.execute(text(query))&#10;&#10;            # Проверяем тип результата&#10;            if query.upper().strip().startswith('SELECT'):&#10;                # Для SELECT-запросов&#10;                rows = result.fetchall()&#10;&#10;                if not rows:&#10;                    await message.answer(&quot; Результатов не найде��о.&quot;)&#10;                    return&#10;&#10;                # Получаем заголовки столбцов&#10;                headers = list(result.keys())&#10;&#10;                # Формируем таблицу в формате Markdown&#10;                table = &quot;| &quot; + &quot; | &quot;.join(headers) + &quot; |\n&quot;&#10;                table += &quot;|&quot; + &quot;|&quot;.join([&quot;---&quot; for _ in headers]) + &quot;|\n&quot;&#10;&#10;                for row in rows:&#10;                    row_data = [str(cell) if cell is not None else &quot;NULL&quot; for cell in row]&#10;                    table += &quot;| &quot; + &quot; | &quot;.join(row_data) + &quot; |\n&quot;&#10;&#10;                # Экранируем специальные символы Markdown&#10;                special_chars = [&#10;                    ('\\', '\\\\'),&#10;                    ('*', '\\*'),&#10;                    ('_', '\\_'),&#10;                    ('[', '\\['),&#10;                    (']', '\\]'),&#10;                    ('(', '\\('),&#10;                    (')', '\\)'),&#10;                    ('~', '\\~'),&#10;                    ('|', '\\|'),&#10;                    ('-', '\\-'),&#10;                    ('.', '\\.')&#10;                ]&#10;&#10;                for char, replacement in special_chars:&#10;                    table = table.replace(char, replacement)&#10;&#10;                # Разделяем на части, если слишком длинная&#10;                max_length = 4096&#10;                if len(table) &gt; max_length:&#10;                    parts = []&#10;                    while len(table) &gt; max_length:&#10;                        part = table[:max_length]&#10;                        parts.append(part)&#10;                        table = table[max_length:]&#10;&#10;                    if table:&#10;                        parts.append(table)&#10;&#10;                    for i, part in enumerate(parts):&#10;                        await message.answer(&#10;                            f&quot; &lt;b&gt;Результат SQL-запроса (часть {i+1}/{len(parts)}):&lt;/b&gt;\n\n&quot;&#10;                            f&quot;```\n{part}\n```&quot;,&#10;                            parse_mode=ParseMode.MARKDOWN_V2&#10;                        )&#10;                else:&#10;                    await message.answer(&#10;                        f&quot; &lt;b&gt;Результат SQL-запроса:&lt;/b&gt;\n\n&quot;&#10;                        f&quot;```\n{table}\n```&quot;,&#10;                        parse_mode=ParseMode.MARKDOWN_V2&#10;                    )&#10;            else:&#10;                # Для INSERT, UPDATE, DELETE запросов&#10;                await db.commit()  # Подтверждаем изменения&#10;                await message.answer(f&quot;✅ &lt;b&gt;SQL-запрос выполнен успешно&lt;/b&gt;\n\nЗатронуто строк: {result.rowcount}&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;        except Exception as e:&#10;            await message.answer(f&quot;❌ &lt;b&gt;Ошибка при выполнении запроса:&lt;/b&gt;\n\n&lt;code&gt;{str(e)}&lt;/code&gt;&quot;, parse_mode=&quot;HTML&quot;)&#10;&#10;&#10;@router.message(Command(&quot;help_admin&quot;))&#10;async def cmd_admin_help(message: Message) -&gt; None:&#10;    &quot;&quot;&quot;Справка по админским командам&quot;&quot;&quot;&#10;    if not _is_admin(message):&#10;        return&#10;&#10;    admin_help = &quot;&quot;&quot;&#10; &lt;b&gt;Справка для администраторов&lt;/b&gt;&#10;&#10; &lt;b&gt;/broadcast&lt;/b&gt; &amp;lt;текст&amp;gt; - Массовая рассылка&#10;   Отправляет сообщение всем пользователям бота&#10;   &#10; &lt;b&gt;/stats&lt;/b&gt; - Подробная статистика&#10;   Показывает количество пользователей, заданий, расписание&#10;   &#10; &lt;b&gt;/thn&lt;/b&gt; - Тест системы напоминаний&#10;   Проверяет работу уведомлений о домашних заданиях&#10;&#10; &lt;b&gt;/sql&lt;/b&gt; &amp;lt;запрос&amp;gt; - Выполнение SQL-запросов&#10;   Позволяет выполнять прямые запросы к базе данных&#10;   &#10; &lt;b&gt;Техническая информация:&lt;/b&gt;&#10;• Планировщики работают каждый час в XX:15&#10;• Архивация: понедельник 02:00&#10;• Вечерние напоминания: ежедневно 20:00&#10;&#10;ℹ️ &lt;b&gt;/help_admin&lt;/b&gt; - Эта справка&#10;&quot;&quot;&quot;&#10;&#10;    await message.answer(admin_help, parse_mode=&quot;HTML&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>